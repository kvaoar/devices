#include "mathstat.h"
#include "stdio.h"
#include "math.h"
#include "stdlib.h"
#include "float.h"

#define STAT_MAX_LEN (50)
#define STAT_MAX_CH (1)
#define N_ITERATION (20)
const int mstat_dbg = 0;
static int N = STAT_MAX_LEN;

uint16_t  arr_index[STAT_MAX_CH]; ///<число измерений по каждому каналу
float     val [STAT_MAX_CH][STAT_MAX_LEN]; ///<значения измерений
uint8_t   mask[STAT_MAX_CH] [STAT_MAX_LEN]; ///<метки удаленных



#define STUDENTSIZE (23)
StudentsKoeff KstTable[STUDENTSIZE] ={
//N,   P=0.8    , P=0.9     , P=0.95    , P=0.99    , P=0.999
{ 10 , {1.3720f	, 1.8125f	, 2.2281f	, 3.1693f	, 4.5869f}},
{ 15 , {1.3406f	, 1.7530f	, 2.1314f	, 2.9467f	, 4.0720f}},
{ 20 , {1.3253f	, 1.7247f	, 2.0860f	, 2.8453f	, 3.8495f}},
{ 25 , {1.3163f	, 1.7081f	, 2.0595f	, 2.7874f	, 3.7251f}},
{ 30 , {1.3104f	, 1.6973f	, 2.0423f	, 2.7500f	, 3.6460f}},
{ 35 , {1.3050f	, 1.6883f	, 2.0281f	, 2.7195f	, 3.5821f}},
{ 40 , {1.3030f	, 1.6839f	, 2.0211f	, 2.7045f	, 3.5510f}},
{ 45 , {1.3000f	, 1.6767f	, 2.0129f	, 2.6870f	, 3.5150f}},
{ 50 , {1.2980f	, 1.6759f	, 2.0086f	, 2.6778f	, 3.4060f}},
{ 55 , {1.2997f	, 1.6730f	, 2.0040f	, 2.6680f	, 3.4760f}},
{ 60 , {1.2958f	, 1.6706f	, 2.0003f	, 2.6603f	, 3.4602f}},
{ 65 , {1.2947f	, 1.6686f	, 1.9970f	, 2.6536f	, 3.4466f}},
{ 70 , {1.2938f	, 1.6689f	, 1.9944f	, 2.6479f	, 3.4350f}},
{ 80 , {1.2820f	, 1.6640f	, 1.9900f	, 2.6380f	, 3.4160f}},
{ 90 , {1.2910f	, 1.6620f	, 1.9867f	, 2.6316f	, 3.4019f}},
{ 100 ,{1.2901f	, 1.6602f	, 1.9840f	, 2.6259f	, 3.3905f}},
{ 120 ,{1.2888f	, 1.6577f	, 1.9719f	, 2.6174f	, 3.3735f}},
{ 150 ,{1.2872f	, 1.6551f	, 1.9759f	, 2.6090f	, 3.3566f}},
{ 200 ,{1.2858f	, 1.6525f	, 1.9719f	, 2.6006f	, 3.3398f}},
{ 250 ,{1.2849f	, 1.6510f	, 1.9695f	, 2.5966f	, 3.3299f}},
{ 300 ,{1.2844f	, 1.6499f	, 1.9679f	, 2.5923f	, 3.3233f}},
{ 400 ,{1.2837f	, 1.6487f	, 1.9659f	, 2.5882f	, 3.3150f}},
{ 500 ,{1.2830f	, 1.6470f	, 1.9640f	, 2.7850f	, 3.3100f}}
};

/**
 * @brief Подсчет числа отсчетов, помаркированных отброшенными
 * @details
 * 1) Счетчик отбракованных величин равен нулю
 * 2) Цикл пробегает все значения маски, хранящейся в mask[i] от 0 до N - глобальные переменные
 * 3) Если данное значение mask[i] активно
 * 4) Счетчик замаскированных значений увеличивается
 * @return - число выбракованных значений
 */
uint16_t MaskCount(int ch){
	uint16_t m = 0; //(1)
	for(uint16_t i = 0; i < N; i++) { //(2)
		if(mask[ch][i] == 1) { //(3)
			m += 1; //(4)
		}
	}
	if(mstat_dbg) printf("MaskCount() deleted = %d\n", m);
	return m;
}

/**
 * @brief Поиск минимального значения в выборке val[MAX_LEN]
 * @details
 * 1) Поиск минимума начинается с максимального значения в локальной переменной m, чтобы ф-я была определена на всем пространстве float
 * 2) Подсчитываем число актуально оставшихся отсчетов как разность всех и отбракованных
 * 3) Если осталось ноль отсчетов - возвращаем ноль
 * 4) Цикл пробегает все значения выборки хранящейся в val[i] от 0 до N - глобальные переменные
 * 5) Если данное значение не замаскировано маской mask[i]
 * 6) Если локальная переменная m больше текущего val[i]
 * 7) В локальную переменную m записывается значение текущего val[i]
 * @return минимальное значение в выборке
 */
float Min(int ch){
	float m = FLT_MAX; // (1)
	uint16_t L = N - MaskCount(ch); //(2)
	if (L == 0)	{//(3)
		if(mstat_dbg) printf("Min() COUNT ZERO\n");
		return 0.0;
	}
	for(uint16_t i = 0; i < N; i++){ //(2)
		if(mask[ch][i] == 0) { //(3)
			if(m > val[ch][i]) //(4)
				m = val[ch][i]; //(5)
		}
	}
	return m;
}

/**
 * @brief Поиск максимального значения в выборке val[MAX_LEN]
 * @details
 * 1) Поиск максимума начинается с минимального значения в локальной переменной m, чтобы ф-я была определена на всем пространстве float
 * 2) Подсчитываем число актуально оставшихся отсчетов как разность всех и отбракованных
 * 3) Если осталось ноль отсчетов - возвращаем ноль
 * 4) Цикл пробегает все значения выборки хранящейся в val[i] от 0 до N - глобальные переменные
 * 5) Если данное значение не замаскировано маской mask[i]
 * 6) Если локальная переменная m меньше текущего val[i]
 * 7) В локальную переменную m записывается значение текущего val[i]
 * @return максимальное значение в выборке
 */
float Max(int ch){
	float m = FLT_MIN; //(1)
	uint16_t L = N - MaskCount(ch); //(2)
	if (L == 0)	{//(3)
		if(mstat_dbg) printf("Max() COUNT ZERO\n");
		return 0.0;
	}
	for(uint16_t i = 0; i < N; i++){//(4)
		if(mask[ch][i] == 0) {//(5)
			if(m < val[ch][i]) //(6)
				m = val[ch][i];//(7)
		}
	}
	return m;
}

/**
 * @brief Матожидание выборки val[MAX_LEN]
 * 1) Локальная переменная m - аккумулятор матожидания, равна нулю
 * 2) Подсчитываем число актуально оставшихся отсчетов как разность всех и отбракованных
 * 3) Если осталось ноль отсчетов - возвращаем матожидание ноль
 * 4) Цикл пробегает все значения выборки хранящейся в val[i] от 0 до N - глобальные переменные
 * 5) Если данное значение не замаскировано маской mask[i]
 * 6) К аккумулятору матожидания прибавляется val[i] (т.о. его тип должен вместить N*MAXFLOAT в худшем случае или N*220 в типичном)
 * 7) Аккумулятор матожидания делится на число неотбракованных отсчетов L и принимает значение матожидания
 * @return - матожидание по выборке
 */
float Mean(int ch){
	double  m = 0.0; //(1)
	uint16_t L = N - MaskCount(ch); //(2)
	if (L == 0)	{//(3)
		if(mstat_dbg)
			printf("mean() COUNT ZERO\n");
		return 0.0;
	}
	for(uint32_t i = 0; i < N; i++)	{//(4)
		if(mask[ch][i] == 0){//(5)
			m += val[ch][i];//(6)
		}
	}
	m = m/L;//(7)
	return (float)m;
}

/**
 * @brief Вычисление стандартного исправленного среднеквадратичного отклонения выборки
 * @details
 * 1) Аккумулятор стандартного отклонения равен нулю
 * 2) Подсчитываем число актуально оставшихся отсчетов как разность всех и отбракованных
 * 3) Если осталось ноль отсчетов - возвращаем стандартное отклонение ноль
 * 4) Цикл пробегает все значения выборки хранящейся в val[i] от 0 до N - глобальные переменные
 * 5) Если данное значение не замаскировано маской mask[i]
 * 6) К аккумулятору стандартного отклонения прибавляется квадрат разности val[i] и матожидания этой выборки
 * 7) Аккумулятор стандартного отклонения делится на число неотбракованных отсчетов L без единицы и принимает значение стандартного отклонения
 * @param mean - мактожидание
 * @return - СКО по выборке
 */
float MeanStandardDeviation(int ch, float mean){
	//if(mstat_dbg) printf("MeanStandardDeviation() mean=%f \n", mean);

	double Sr = 0; //(1)
	uint16_t L = N - MaskCount(ch); //(2)
	if (L == 0)	{//(3)
		if(mstat_dbg)
			printf("MeanStandardDeviation() COUNT ZERO\n");
		return (float)Sr;
	}
	for(int i = 0; i <N; i++){ //(4)
		if(mask[ch][i] == 0){ //(5)
			Sr += ((mean - val[ch][i])*(mean - val[ch][i])); //(6)
			//if(1)  printf("MeanStandardDeviation() i = %d Sr = %g\n",i, Sr);
			}
	}
	Sr =  sqrt(Sr/(L*(L-1)));//(7)
	if(mstat_dbg)
		printf("MeanStandardDeviation()Sr = %f\n", Sr);
	return (float)Sr;
}

/**
 * @brief Нахождение ближайшего в таблице коэффициента Стьюдента для заданных N и P
 * @details
 * 1) Число в min используется для детекции наименьшей разницы между Ns и num, поэтому вначале имеет UINT16_MAX
 * 2) Если Ns меньше минимальной выборки, выдается к-т гарантированно перекрывающий выборку
 * 3) Если Ns больше максимальной выборки, выдается к-т который с 99,99999.. гарантирует попадание в выборку (но вообще это переполнение)
 * 4) Проходим по всем строкам таблицы коэффициента Стьюдента
 * 5) Получаем число измерений, для которого эта строка, в переменную num
 * 6) Проверяем, действительно ли разница по модулю между num и Ns меньше min
 * 7) Если да - обновляем значение min до этой разницы
 * 8) И записываем в INDEX номер той записи в таблице, для которой разница оказалась меньшей
 * 9) Очевидно, что по прохождении всей таблицы в INDEX будет находиться номер строки, наиболее близкой к Ns. Извлекаем коэффициент.
 * @param Ns - число элементов выборки, для которых были рассчитаны статистические параметры
 * @param P - PStud перечисление 	P0_80  = 0,	P0_90  = 1,	P0_95  = 2,	P0_99  = 3,	P0_999 = 4
 * @return - коэффициент Стьюдента
 */
float GetStudentsKoefficient(uint16_t Ns, PStud P){
uint16_t INDEX = 0;
uint16_t min = UINT16_MAX; //(1)

if( Ns < 10) return 6.0f; //(2)
if (Ns > STAT_MAX_LEN) return 6.0f; //(3)

for(int i = 0; i < STUDENTSIZE; i++) //(4)
{
	uint16_t num = KstTable[i].N; //(5)
	if(abs(Ns - num) < min) //(6)
	{
		min = (Ns - num); //(7)
		INDEX = i; //(8)
	}
}
	return KstTable[INDEX].k[P]; //(9)
}

/**
 * @brief Вычисление доверительного интервала с учетом границы по точности (например, размер кванта ацп)
 * @details
 * 1) Подсчитываем число актуально оставшихся отсчетов как разность всех и отбракованных
 * 2) Получаем к-т Стьюдента для данного числа отсчетов и доверительной вероятности
 * 3) Находим доверительный интервал
 * @param Sr - стандартное исправленное СКО выборки
 * @param user_Q - заданная граничная точность при которой фильтрация останавливается
 * @param P - заданная вероятность попадания элемента выборки в доверительный интервал
 * @return - доверительный интервал
 */
float StudentDelta(int ch, float Sr, uint8_t P){
uint32_t L = N - MaskCount(ch); //(1)
float k = GetStudentsKoefficient(L, P); //(2)
if(mstat_dbg)
	printf(" Tst = %f\n",k);
float delta = Sr*k; //(3)
return delta;
}

/**
 * @brief Фильтрация выборки по критерию Стьюдента отбраковывает выходящие за границу достоверности значения
 * @details Произведение к-та Стьюдента и дисперсии соответствует тому отклонению от среднего
 * при данной дисперсии,которое не случится с вероятностью P.
 * 1) Счетчик отсчетов, помаркированных за данный проход как не валидные данные
 * 2) Цикл пробегает все значения выборки хранящейся в val[i] от 0 до N - глобальные переменные
 * 3) Если абсолютное значение отклонения отсчета val[i] от матожидания выборки выходит за доверительный интервал
 * 4) Отсчет маркируется как невалидный
 * 5) Счетчик невалидных отсчетов инкрементируется
 * @param mean - Оценка матожидания по выборке
 * @param delta - Доверительный интервал выборки
 * @return - число отброшенных измерений
 */
uint16_t StudentFilter(int ch,float mean, float delta){
	uint16_t deleted = 0; //(1)
	for(uint16_t i = 0; i < N; i++) //(2)
	{
	if( fabsf(val[ch][i] - mean) > delta ) //(3)
			{
			mask[ch][i] = 1; //(4)
			deleted++; //(5)
			if(mstat_dbg)
				printf("StudentFilter() val=%f m[val]=%f delta=%f delta_max=%f\n", val[ch][i], mean, fabsf(val[ch][i]-mean), delta );
			}
	}
	return deleted;
}

/**
 * @brief Интерфейс установки глобальной длины выборки
 * @details Если длина выборки больше длины буфера - будет установлена длина буфера
 * @param Len - желаемая длина выборки
 */
void SetLength(uint16_t Len){
	if(Len <STAT_MAX_LEN)
		N = Len;
	else
		{
		N = STAT_MAX_LEN;
		if(mstat_dbg)
			printf("SetLength(%d) but max len %d, N = MAX_LEN\n", Len, STAT_MAX_LEN);
		}
}

/**
 * @brief Получает длину выборки установленную для модуля
 * @return длина выборки
 */
uint16_t GetLength(){
	return N;
}

/**
 * @brief Функция может вызываться в цикле опроса, накапливая данные.
 * @details
 * 1) Глобальный счетчик отсчетов, он же индекс массива, проверяется на число сохраненных измерений
 * 2) В массив добавляется отсчет
 * 3) Индекс массива увеличивается на единицу
 * @param val_n - значение отсчета
 * @return - 1 - если массив не заполнен, 0 - если заполнен
 */
uint8_t FillData(int ch, float val_n){
	if(arr_index[ch] < N) //(1)
	{
		uint16_t i =arr_index[ch];
		val[ch][i] = val_n; //(2)		//1.01851851*U= 220v
		 arr_index[ch] += 1;//(3)
		 if(mstat_dbg)
			 printf("arr_index[ch] %d ch %d, val_n %f, val[ch][i] %f, arr_indx[ch] %d\n",i,ch, val_n,val[ch][i],arr_index[ch]);
		 return 1;
	}
	else
	{
	if(mstat_dbg)
		for(int i = 0; i < N; i++)
			printf("%f\n",val[ch][i]);
	return 0;
	}
}

/**
 * @brief Статистическая обработка выборки для прямого измерения
 * @details
 * 1) Если собрано запланированное к обработке число отсчетов
 * 2) Глобальный счетчик нужного количества отсчетов обнуляется
 * 3) В предыущую актуальную длину выборки записывается текущая
 * 4) Вычисляется новая текущая длина
 * 5) Вычисляется матожидание выборки
 * 6) Вычисляется стандартное отклонение
 * 7) Вычисляется доверительный интервал
 * 8) Определяется положение имеющейся по выборке точности относительно пользовательского диапазона самой низкой и самой высокой точности
 * 8.1) Если квант по выборке меньше кванта высшей допустимой точности - выбирается второй, и ставится HIGH поля qual
 * 8.2) Если квант по выборке больше кванта низшей допустимой точности - выбирается второй, и ставится LOW поля qual
 * 8.3) Если неверны предыдущие два условия - значит квант лежит в диапазоне допустимой точности и получает флаг MED
 * 9) Вычисляется минимум выборки
 * 10) Вычисляется максимум выборки
 * 11) Отбрасываются отсчеты, выбивающиеся за доверительный интервал
 * 12) Цикл идет к (3), либо кончается, если выборка сошлась (не отброшено ни одного значения) или прошло N_ITERATION циклов
 * 13) Если выборка сошлась раньше отсечки по числу итераций - поле stabil олучает флаг STABLE, иначе - UNSTABLE
 * 14) Цикл проходит по всей выборке
 * 15) Очистка маски отбраковки
 * 16) Очистка значения измерения
 * @param delta
 * @return
 */
StatResult Calculate(int ch, float high_Q, float low_Q){
	uint16_t old_L = 0, L = 0;
	StatResult res;
	res.p = P0_95;

	if (ch >= STAT_MAX_CH)
	return res;

if(arr_index[ch] == N) //(1)
	{
	arr_index[ch] = 0; //(2)
		int t = 0;
		do{
				old_L = L; // (3)
			    L = N - MaskCount(ch); // (4)
			    float Mu = Mean(ch); // (5)
			    float Su= MeanStandardDeviation(ch,Mu); // (6)
			    float dx = StudentDelta(ch,Su,res.p); // (7)

			    if(dx < high_Q)
			    {
			    	//(8.1)
			    	dx = high_Q;
			    	res.qual = HIGH;
			    }
			    else
			    if(dx > low_Q)
			    {
			    	//(8.2)
			    	dx = low_Q;
			    	res.qual = LOW;
			    }
			    else
			    {
			    	// (8.3)
			    	res.qual = MED;
			    }

				//float mi = Min(); // (9)
				//float ma = Max(); // (10)
				//uint16_t deleted = StudentFilter(Mu,dx); // (11)
				res.value = Mu;
				res.delta = dx;
		}while((old_L != L)&(++t < N_ITERATION)); //(12)

		if(old_L != L) // (13)
		{
			res.stabil = UNSTABLE;
			if(mstat_dbg)
				printf("Выборка не стабильна, среднего нет!!!\n");
		}
		else
		{
			res.stabil = STABLE;
			if(mstat_dbg)
				printf("---OK---\n");
		}

		for(int k = 0; k < N; k++) // (14)
		{
			mask[ch][k] = 0; //(15)
			val[ch][k] = 0; //(16)
		}
	}// if arr index >=N
else
printf("Недостаточно отсчетов!\n");

return res;
}




